def a_single_sol(n):
    # -*- coding: utf-8 -*-
    """Bessel-sim4s.ipynb

    Automatically generated by Colaboratory.

    Original file is located at
        https://colab.research.google.com/drive/1Q9NnfKSa0qs_ea-NtGP6J6VrIt5iAZ8Y

    ## Solución analítica

    Test simulation --> 2D acoustic pulse propagation case in a uniform flow.

    Initial perturbation --> Gaussian pressure distribution imposed at the centre of the domain at t=0:

    $p(x,y,0)$ --> eq. (4-39) in Schmalz-Thesis,2016.pdf

    The analytical solution for the pressure (obtained from **LEE**) is given by a Bessel function of order zero:

    $p(r,t)$ --> eq. (2) in Toth,2008.pdf

    $p(r,t)$ --> eq. (B11) in Tam,1993.pdf
    """

    import numpy as np
    import scipy.integrate as integrate
    import scipy.special as special

    # Parameters
    b = 3  # Gaussian half width
    alpha = np.log(2)/b**2
    a0 = 0.01  # Gaussian amplitude
    c0 = 346.3  # speed of sound [m/s] --> velocity scale
    M = 0.5  # inlet is a uniform flow with Ux=M [m/s]

    # Domain size --> /OpenFOAM/ale-6/run/Schmalz/sim4s/system/blockMeshDict
    blocks = 200  # number of divisions in x-direction
    L = 55.0  # [m] Según Toth,2008.pdf
    x0 = -L
    xN = L
    y0 = -L
    yN = L
    deltax = (xN-x0)/blocks  # grid spacing [m] --> length scale

    # Density field is prescribed through constitutive equation --> ideal gas law
    R = 287.038  # specific gas constant [J/kgK]
    p0 = 101325  # initial pressure [Pa]
    T0 = 300  # initial temperature [K]
    rho0 = p0/(R*T0)  # [kg/m^3]

    # Bessel function of the first kind of real order 'v' and complex argument 'z'
    # ---> scipy.special.jn(v,z)

    def integrand(xi, r, t):
        return np.exp((-xi**2)/(4*alpha))*np.cos(xi*t)*special.jn(0, xi*r)*xi

    def besselint(r, t):
        return (a0/2*alpha)*integrate.quad(integrand, 0, np.inf, args=(r, t))[0]

    vec_besselint = np.vectorize(besselint)

    # Perfiles eje (x,y=0)
    x_adi = np.arange(-100, 100, 0.55)  # []
    y = 0  # [m]
    y_adi = y/deltax  # []
    t1 = 0.00016  # [s]
    dt = 0.016  # [s]
    t = t1+n*dt  # [s]
    t_adi = t*c0/deltax  # []
    r_adi = np.sqrt((x_adi-M*t_adi)**2+y_adi**2)  # []
    perfil = vec_besselint(r_adi, t_adi)  # []
    perfil1 = perfil*rho0*c0**2  # [Pa]
    data = [x_adi, perfil1, t]
    return data
